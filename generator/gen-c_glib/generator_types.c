/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "generator_types.h"
#include <thrift/c_glib/thrift.h>

enum _NodeProperties
{
  PROP_NODE_0,
  PROP_NODE_PROPS,
  PROP_NODE_LABELS
};

/* reads a node object */
static gint32
node_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Node * this_object = NODE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key0 = NULL;
              gchar * val1 = NULL;
              if (key0 != NULL)
              {
                g_free(key0);
                key0 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key0, error)) < 0)
                return -1;
              xfer += ret;
              if (val1 != NULL)
              {
                g_free(val1);
                val1 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &val1, error)) < 0)
                return -1;
              xfer += ret;
              if (this_object->props && key0)
                g_hash_table_insert ((GHashTable *)this_object->props, (gpointer) key0, (gpointer) val1);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_props = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem2 = NULL;
              if (_elem2 != NULL)
              {
                g_free(_elem2);
                _elem2 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem2, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->labels, _elem2);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_labels = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
node_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Node * this_object = NODE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Node", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "props", T_MAP, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    gchar * key3 = NULL;
    gchar * val4 = NULL;
    GList *key_list = NULL, *iter = NULL;
    gchar ** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRING, this_object->props ? (gint32) g_hash_table_size ((GHashTable *) this_object->props) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->props)
      g_hash_table_foreach ((GHashTable *) this_object->props, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gchar *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gchar *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key3 = keys[i];
      val4 = (gchar *) g_hash_table_lookup (((GHashTable *) this_object->props), (gpointer) key3);

      if ((ret = thrift_protocol_write_string (protocol,  key3, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_protocol_write_string (protocol,  val4, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "labels", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i5;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->labels ? this_object->labels->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i5 = 0; i5 < (this_object->labels ? this_object->labels->len : 0); i5++)
    {
      if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->labels, i5)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
node_set_property (GObject *object,
                   guint property_id,
                   const GValue *value,
                   GParamSpec *pspec)
{
  Node *self = NODE (object);

  switch (property_id)
  {
    case PROP_NODE_PROPS:
      if (self->props != NULL)
        g_hash_table_unref (self->props);
      self->props = g_value_dup_boxed (value);
      self->__isset_props = TRUE;
      break;

    case PROP_NODE_LABELS:
      if (self->labels != NULL)
        g_ptr_array_unref (self->labels);
      self->labels = g_value_dup_boxed (value);
      self->__isset_labels = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
node_get_property (GObject *object,
                   guint property_id,
                   GValue *value,
                   GParamSpec *pspec)
{
  Node *self = NODE (object);

  switch (property_id)
  {
    case PROP_NODE_PROPS:
      g_value_set_boxed (value, self->props);
      break;

    case PROP_NODE_LABELS:
      g_value_set_boxed (value, self->labels);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
node_instance_init (Node * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->props = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
  object->__isset_props = FALSE;
  object->labels = g_ptr_array_new_with_free_func (g_free);
  object->__isset_labels = FALSE;
}

static void 
node_finalize (GObject *object)
{
  Node *tobject = NODE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->props != NULL)
  {
    g_hash_table_destroy (tobject->props);
    tobject->props = NULL;
  }
  if (tobject->labels != NULL)
  {
    g_ptr_array_unref (tobject->labels);
    tobject->labels = NULL;
  }
}

static void
node_class_init (NodeClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = node_read;
  struct_class->write = node_write;

  gobject_class->finalize = node_finalize;
  gobject_class->get_property = node_get_property;
  gobject_class->set_property = node_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_NODE_PROPS,
     g_param_spec_boxed ("props",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_NODE_LABELS,
     g_param_spec_boxed ("labels",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
node_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (NodeClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) node_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Node),
      0, /* n_preallocs */
      (GInstanceInitFunc) node_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "NodeType",
                                   &type_info, 0);
  }

  return type;
}

enum _ResponseProperties
{
  PROP_RESPONSE_0,
  PROP_RESPONSE_TEXT,
  PROP_RESPONSE_NODES
};

/* reads a response object */
static gint32
response_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Response * this_object = RESPONSE(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->text != NULL)
          {
            g_free(this_object->text);
            this_object->text = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->text, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_text = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              Node * _elem6 = NULL;
              if ( _elem6 != NULL)
              {
                g_object_unref (_elem6);
              }
              _elem6 = g_object_new (TYPE_NODE, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem6), protocol, error)) < 0)
              {
                g_object_unref (_elem6);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->nodes, _elem6);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_nodes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
response_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Response * this_object = RESPONSE(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Response", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "text", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->text, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "nodes", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i7;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->nodes ? this_object->nodes->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i7 = 0; i7 < (this_object->nodes ? this_object->nodes->len : 0); i7++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->nodes, i7))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
response_set_property (GObject *object,
                       guint property_id,
                       const GValue *value,
                       GParamSpec *pspec)
{
  Response *self = RESPONSE (object);

  switch (property_id)
  {
    case PROP_RESPONSE_TEXT:
      if (self->text != NULL)
        g_free (self->text);
      self->text = g_value_dup_string (value);
      self->__isset_text = TRUE;
      break;

    case PROP_RESPONSE_NODES:
      if (self->nodes != NULL)
        g_ptr_array_unref (self->nodes);
      self->nodes = g_value_dup_boxed (value);
      self->__isset_nodes = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
response_get_property (GObject *object,
                       guint property_id,
                       GValue *value,
                       GParamSpec *pspec)
{
  Response *self = RESPONSE (object);

  switch (property_id)
  {
    case PROP_RESPONSE_TEXT:
      g_value_set_string (value, self->text);
      break;

    case PROP_RESPONSE_NODES:
      g_value_set_boxed (value, self->nodes);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
response_instance_init (Response * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->text = NULL;
  object->__isset_text = FALSE;
  object->nodes = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_nodes = FALSE;
}

static void 
response_finalize (GObject *object)
{
  Response *tobject = RESPONSE (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->text != NULL)
  {
    g_free(tobject->text);
    tobject->text = NULL;
  }
  if (tobject->nodes != NULL)
  {
    g_ptr_array_unref (tobject->nodes);
    tobject->nodes = NULL;
  }
}

static void
response_class_init (ResponseClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = response_read;
  struct_class->write = response_write;

  gobject_class->finalize = response_finalize;
  gobject_class->get_property = response_get_property;
  gobject_class->set_property = response_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_RESPONSE_TEXT,
     g_param_spec_string ("text",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_RESPONSE_NODES,
     g_param_spec_boxed ("nodes",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
response_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (ResponseClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) response_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Response),
      0, /* n_preallocs */
      (GInstanceInitFunc) response_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "ResponseType",
                                   &type_info, 0);
  }

  return type;
}

enum _RequestProperties
{
  PROP_REQUEST_0,
  PROP_REQUEST_COMMAND_TYPE,
  PROP_REQUEST_NODE,
  PROP_REQUEST_NODE_UPDATES
};

/* reads a request object */
static gint32
request_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  Request * this_object = REQUEST(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->command_type, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_command_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->node), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_node = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->node_updates), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_node_updates = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
request_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  Request * this_object = REQUEST(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Request", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "command_type", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->command_type, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "node", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->node), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "node_updates", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->node_updates), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
request_set_property (GObject *object,
                      guint property_id,
                      const GValue *value,
                      GParamSpec *pspec)
{
  Request *self = REQUEST (object);

  switch (property_id)
  {
    case PROP_REQUEST_COMMAND_TYPE:
      self->command_type = g_value_get_int (value);
      self->__isset_command_type = TRUE;
      break;

    case PROP_REQUEST_NODE:
      if (self->node != NULL)
        g_object_unref (self->node);
      self->node = g_value_dup_object (value);
      self->__isset_node = TRUE;
      break;

    case PROP_REQUEST_NODE_UPDATES:
      if (self->node_updates != NULL)
        g_object_unref (self->node_updates);
      self->node_updates = g_value_dup_object (value);
      self->__isset_node_updates = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
request_get_property (GObject *object,
                      guint property_id,
                      GValue *value,
                      GParamSpec *pspec)
{
  Request *self = REQUEST (object);

  switch (property_id)
  {
    case PROP_REQUEST_COMMAND_TYPE:
      g_value_set_int (value, self->command_type);
      break;

    case PROP_REQUEST_NODE:
      g_value_set_object (value, self->node);
      break;

    case PROP_REQUEST_NODE_UPDATES:
      g_value_set_object (value, self->node_updates);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
request_instance_init (Request * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->command_type = 0;
  object->__isset_command_type = FALSE;
  object->node = g_object_new (TYPE_NODE, NULL);
  object->__isset_node = FALSE;
  object->node_updates = g_object_new (TYPE_NODE, NULL);
  object->__isset_node_updates = FALSE;
}

static void 
request_finalize (GObject *object)
{
  Request *tobject = REQUEST (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->node != NULL)
  {
    g_object_unref(tobject->node);
    tobject->node = NULL;
  }
  if (tobject->node_updates != NULL)
  {
    g_object_unref(tobject->node_updates);
    tobject->node_updates = NULL;
  }
}

static void
request_class_init (RequestClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = request_read;
  struct_class->write = request_write;

  gobject_class->finalize = request_finalize;
  gobject_class->get_property = request_get_property;
  gobject_class->set_property = request_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_REQUEST_COMMAND_TYPE,
     g_param_spec_int ("command_type",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_REQUEST_NODE,
     g_param_spec_object ("node",
                         NULL,
                         NULL,
                         TYPE_NODE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_REQUEST_NODE_UPDATES,
     g_param_spec_object ("node_updates",
                         NULL,
                         NULL,
                         TYPE_NODE,
                         G_PARAM_READWRITE));
}

GType
request_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (RequestClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) request_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (Request),
      0, /* n_preallocs */
      (GInstanceInitFunc) request_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "RequestType",
                                   &type_info, 0);
  }

  return type;
}

/* constants */

enum _TestPingArgsProperties
{
  PROP_TEST_PING_ARGS_0,
  PROP_TEST_PING_ARGS_REQUEST
};

/* reads a test_ping_args object */
static gint32
test_ping_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TestPingArgs * this_object = TEST_PING_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->request), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_request = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
test_ping_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TestPingArgs * this_object = TEST_PING_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TestPingArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "request", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->request), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
test_ping_args_set_property (GObject *object,
                             guint property_id,
                             const GValue *value,
                             GParamSpec *pspec)
{
  TestPingArgs *self = TEST_PING_ARGS (object);

  switch (property_id)
  {
    case PROP_TEST_PING_ARGS_REQUEST:
      if (self->request != NULL)
        g_object_unref (self->request);
      self->request = g_value_dup_object (value);
      self->__isset_request = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
test_ping_args_get_property (GObject *object,
                             guint property_id,
                             GValue *value,
                             GParamSpec *pspec)
{
  TestPingArgs *self = TEST_PING_ARGS (object);

  switch (property_id)
  {
    case PROP_TEST_PING_ARGS_REQUEST:
      g_value_set_object (value, self->request);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
test_ping_args_instance_init (TestPingArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->request = g_object_new (TYPE_REQUEST, NULL);
  object->__isset_request = FALSE;
}

static void 
test_ping_args_finalize (GObject *object)
{
  TestPingArgs *tobject = TEST_PING_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->request != NULL)
  {
    g_object_unref(tobject->request);
    tobject->request = NULL;
  }
}

static void
test_ping_args_class_init (TestPingArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = test_ping_args_read;
  struct_class->write = test_ping_args_write;

  gobject_class->finalize = test_ping_args_finalize;
  gobject_class->get_property = test_ping_args_get_property;
  gobject_class->set_property = test_ping_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TEST_PING_ARGS_REQUEST,
     g_param_spec_object ("request",
                         NULL,
                         NULL,
                         TYPE_REQUEST,
                         G_PARAM_READWRITE));
}

GType
test_ping_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TestPingArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) test_ping_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TestPingArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) test_ping_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TestPingArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _TestPingResultProperties
{
  PROP_TEST_PING_RESULT_0,
  PROP_TEST_PING_RESULT_SUCCESS
};

/* reads a test_ping_result object */
static gint32
test_ping_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  TestPingResult * this_object = TEST_PING_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
test_ping_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  TestPingResult * this_object = TEST_PING_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "TestPingResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
test_ping_result_set_property (GObject *object,
                               guint property_id,
                               const GValue *value,
                               GParamSpec *pspec)
{
  TestPingResult *self = TEST_PING_RESULT (object);

  switch (property_id)
  {
    case PROP_TEST_PING_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
test_ping_result_get_property (GObject *object,
                               guint property_id,
                               GValue *value,
                               GParamSpec *pspec)
{
  TestPingResult *self = TEST_PING_RESULT (object);

  switch (property_id)
  {
    case PROP_TEST_PING_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
test_ping_result_instance_init (TestPingResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (TYPE_RESPONSE, NULL);
  object->__isset_success = FALSE;
}

static void 
test_ping_result_finalize (GObject *object)
{
  TestPingResult *tobject = TEST_PING_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
}

static void
test_ping_result_class_init (TestPingResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = test_ping_result_read;
  struct_class->write = test_ping_result_write;

  gobject_class->finalize = test_ping_result_finalize;
  gobject_class->get_property = test_ping_result_get_property;
  gobject_class->set_property = test_ping_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_TEST_PING_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         TYPE_RESPONSE,
                         G_PARAM_READWRITE));
}

GType
test_ping_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (TestPingResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) test_ping_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (TestPingResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) test_ping_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "TestPingResultType",
                                   &type_info, 0);
  }

  return type;
}

